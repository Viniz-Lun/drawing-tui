#include <stdlib.h>
#include <fcntl.h>
#include <string.h>
#include <unistd.h>
#include "myColor.h"
#include "curse-files.h"

#include <limits.h>
/* SECTION OF CODE AI-GENERATED BY GOOGLE GEMINI:*/

/* * Helper function to get the standard RGB (0-255) value
 * for a specific bash 256-color code (0-255).
 */
void get_bash_color_rgb(int code, int *r, int *g, int *b) {
    // 1. Standard System Colors (0-15)
    // These specific hex values are the standard Xterm defaults.
    if (code < 16) {
        // 0-7: Standard
        if (code == 0) { *r = 0;   *g = 0;   *b = 0;   }      // Black
        else if (code == 1) { *r = 128; *g = 0;   *b = 0;   } // Maroon
        else if (code == 2) { *r = 0;   *g = 128; *b = 0;   } // Green
        else if (code == 3) { *r = 128; *g = 128; *b = 0;   } // Olive
        else if (code == 4) { *r = 0;   *g = 0;   *b = 128; } // Navy
        else if (code == 5) { *r = 128; *g = 0;   *b = 128; } // Purple
        else if (code == 6) { *r = 0;   *g = 128; *b = 128; } // Teal
        else if (code == 7) { *r = 192; *g = 192; *b = 192; } // Silver
        // 8-15: High Intensity (Bright)
        else if (code == 8) { *r = 128; *g = 128; *b = 128; } // Grey
        else if (code == 9) { *r = 255; *g = 0;   *b = 0;   } // Red
        else if (code == 10){ *r = 0;   *g = 255; *b = 0;   } // Green
        else if (code == 11){ *r = 255; *g = 255; *b = 0;   } // Yellow
        else if (code == 12){ *r = 0;   *g = 0;   *b = 255; } // Blue
        else if (code == 13){ *r = 255; *g = 0;   *b = 255; } // Magenta
        else if (code == 14){ *r = 0;   *g = 255; *b = 255; } // Cyan
        else if (code == 15){ *r = 255; *g = 255; *b = 255; } // White
        return;
    }

    // 2. 6x6x6 Color Cube (16-231)
    // Formula: 16 + (36 * r) + (6 * g) + b
    if (code < 232) {
        int cube_code = code - 16;
        int r_idx = cube_code / 36;
        int g_idx = (cube_code % 36) / 6;
        int b_idx = cube_code % 6;

        // Mapping 0-5 index to specific byte values used by Xterm
        // 0 -> 0, non-zero -> (index * 40 + 55)
        // Sequence: 0, 95, 135, 175, 215, 255
        *r = (r_idx == 0) ? 0 : (r_idx * 40 + 55);
        *g = (g_idx == 0) ? 0 : (g_idx * 40 + 55);
        *b = (b_idx == 0) ? 0 : (b_idx * 40 + 55);
        return;
    }

    // 3. Grayscale Ramp (232-255)
    // Formula: 232 is 0x08 (8), each step adds 10 (0x0A).
    // Ends at 238 (0xEE).
    if (code < 256) {
        int gray_idx = code - 232;
        int val = 8 + (gray_idx * 10);
        *r = val;
        *g = val;
        *b = val;
        return;
    }
}

int bash_code_closest_match(Color color) {
    // 1. Normalize input (0-1000) to standard RGB (0-255)
    // We use integer math: (val * 255) / 1000
    int target_r = (color.rgb.r * 255) / 1000;
    int target_g = (color.rgb.g * 255) / 1000;
    int target_b = (color.rgb.b * 255) / 1000;

    int best_code = 0;
    long min_distance_sq = LONG_MAX;

    // 2. Iterate over all 256 colors to find the closest match
    for (int code = 0; code < 256; code++) {
        int r, g, b;
        get_bash_color_rgb(code, &r, &g, &b);

        // Calculate squared Euclidean distance
        long dr = r - target_r;
        long dg = g - target_g;
        long db = b - target_b;
        long distance_sq = (dr * dr) + (dg * dg) + (db * db);

        if (distance_sq < min_distance_sq) {
            min_distance_sq = distance_sq;
            best_code = code;

            // Optimization: If exact match, break early
            if (min_distance_sq == 0) return best_code;
        }
    }

    return best_code;
}
/* END OF SECTION OF AI-GENERATED CODE */

/*
 * TABLE-OF-EFFECTS:
 * 0 - NORMAL/RESET
 * 1 - BOLD
 * 2 - FAINT
 * 3 - ITALIC
 * 4 - UNDERLINE
 * 5 - BLINK
 * 6 - MY DEFINITION - when in color, use terminal defaults
 * 7 - REVERSE
 */
void translate(attr_t mask, Context context, int result[3], bool with_color, bool withBgColor){
	result[0] = 0;
	if( mask & A_BOLD ){
		result[0] = 1;
	}
	if( mask & A_INVIS ){
		result[0] = 2;
	}
	if( mask & A_ITALIC ){
		result[0] = 3;
	}
	if( mask & A_UNDERLINE ){
		result[0] = 4;
	}
	if( mask & A_BLINK ){
		result[0] = 5;
	}
	if( mask & A_REVERSE ){
		result[0] = 7;
	}

	if( with_color ){
		Pair toCodify;
		short attrPairNum = PAIR_NUMBER(mask);
		Pair* pairs = context.color_pairs.colPointer;

		if( !withBgColor && attrPairNum == 0 && result[0] == 0 ){
			result[0] = 6;
			return;
		}

		for( int i = 0; i < context.color_pairs.maxDim; i++ ){
			if( pairs[i].pairNum == attrPairNum){
				toCodify = pairs[i];
				break;
			}
		}
		result[1] = bash_code_closest_match(toCodify.fg);
		result[2] = bash_code_closest_match(toCodify.bg);
	}
}

void codify_visual_string(char* stringToCode, int maxlen, int code[3], bool with_color){
	if(with_color && code[0] != 6){
		snprintf(stringToCode, maxlen, 
			"\e[%d;38;5;%d;48;5;%dm", 
			code[0], code[1], code[2]);
	}
	else{
		snprintf(stringToCode, maxlen, 
			"\e[%d;m", 
			code[0] == 6 ? 0: code[0]);
	}
	return;
}

void print_help(){
	printf("Tool to translate a .curse file, formatted correctly,\n\
and write it to a file (default output file: ./BashCodedFile).\n\
\n\
-h for this help\n\
-t to truncate the drawing to only the rectangle area that has been drawn on.\n\
-c for no color. (keeps effects like reverse, blinking, bold, etc.)\n\
-b to preserve the background color of uncolored cells.\n\
-p Instead of producing a BasCodedFile, produces a PlainFile, which is a plain text file.\n\
   Such file contains only the ascii characters of the drawing.\n\
-o To direct the output into a file of your choosing.\n\
\n\
To be able to visualize your converted drawing in bash, simply run:\n\
< cat [NAME-OF-FILE-PRODUCED] >\n\
which will intepret all the colors and empty spaces correctly (if your terminal supports it).\n\
");
}

int main(int argc, char** argv){
	int opt;
	bool withBgColor, truncate, plain, with_color;
	char new_file[256] = {0};

	with_color = true;
	withBgColor = true;
	truncate = false;
	plain = false;

	while ((opt = getopt(argc, argv, ":o:thcbp")) != -1) {
			switch (opt) {
				case 'c':
					with_color = false;
					break;
				case 't':
					truncate = true;
					break;
				case 'b':
					withBgColor = false;
					break;
				case 'p':
					plain = true;
					break;
				case 'o':
					strncpy(new_file, optarg, 255);
					break;
				case '?':
					puts("Unknown option");
					exit(2);
					break;
				case ':':
					puts("Missing argument for option");
					exit(2);
				case 'h':
				default:
					print_help();
					exit(0);
					break;
			}
	}

	if( plain ){
		with_color = false;
		withBgColor = false;
	}

	int fd, newFile, filePos;

	fd = open(argv[optind], O_RDONLY);
	if( fd < 0 ){
		puts("Expected name of existing file\n\
use: translator <FILE>\n\
translator -h for more options");
		exit(3);
	}
	

	if( !plain ){
		if( new_file[0] == 0 ) strncpy(new_file, "BashCodedFile", 255);
	}
	else{
		if( new_file[0] == 0 ) strncpy(new_file, "PlainFile", 255);
	}

	newFile = open(new_file, O_TRUNC | O_WRONLY | O_CREAT, 0644);
	if( newFile < 0 ){
		puts("Error creating new file\n");
		exit(3);
	}

	Context context;

	initialize_collection(&context.color_pairs, 126, sizeof(Pair));
	initialize_collection(&context.custom_colors, 255, sizeof(Color));
	
	//assuming it is .curse file formatted correctly
	filePos = initialize_colors_from_file(fd, 0, &context);
	if( filePos < 1 ){
		puts("Error reading colors from file");
		close(fd);
		exit(1);
	}

	filePos = initialize_pairs_from_file(fd, filePos, &context);
	if( filePos < 1 ){
		puts("Error reading pairs from file");
		close(fd);
		exit(1);
	}

	int nread;
	attr_t curAttr, prev = -1;
	int tr_maxline, tr_minline;
	int tr_maxcol, tr_mincol;
	int curCol, curLine;
	chtype ch;

	tr_maxline = 0;
	tr_minline = 9999;
	tr_maxcol = 0;
	tr_mincol = 9999;
	curCol = 0;
	curLine = 0;

	if( truncate ){
		while( (nread = read(fd, &ch, sizeof(chtype))) > 0){
			curAttr= ch & 0xffffff00;
			ch = ch & A_CHARTEXT;

			if( ch == '\n' ){
				curCol = 0;
				curLine++;
			}
			else{
				if( ch != ' ' || (with_color && PAIR_NUMBER(curAttr) != 0) ){
					if( curCol < tr_mincol ) tr_mincol = curCol;
					if( curCol > tr_maxcol ) tr_maxcol = curCol;
					if( curLine < tr_minline ) tr_minline = curLine;
					if( curLine > tr_maxline ) tr_maxline = curLine;
				}
				curCol++;
			}
		}
	}

	int newCodes[3];
	char newCodeString[64];
	bool printableLine, printableCol;

	lseek(fd, filePos, SEEK_SET);
	curCol = 0;
	curLine = 0;

	while( (nread = read(fd, &ch, sizeof(chtype))) > 0){
		curAttr= ch & 0xffffff00;
		ch = ch & A_CHARTEXT;

		if( !plain && curAttr!= prev ){
			translate(curAttr, context, newCodes, with_color, withBgColor);

			codify_visual_string(newCodeString, sizeof(newCodeString), newCodes, with_color);

			write(newFile, newCodeString, strlen(newCodeString));

			prev = curAttr;
		}
		
		if( !truncate ) write(newFile, &ch, sizeof(char));
		if( truncate ){
			printableLine = curLine >= tr_minline &&
						 curLine <= tr_maxline;
			printableCol = curCol >= tr_mincol &&
						curCol <= tr_maxcol;

			if( printableLine ){
				if( printableCol || ch == '\n' )
					write(newFile, &ch, sizeof(char));
			}
			if(ch == '\n'){
				curLine++;
				curCol = 0;
			}
			else curCol++;
		}//truncate
	}//while

	if( !plain ) write(newFile, "\e[0m", strlen("\\[0m"));

	free(context.color_pairs.colPointer);
	free(context.custom_colors.colPointer);
	exit(0);
}
