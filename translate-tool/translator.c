#include <stdlib.h>
#include <fcntl.h>
#include <string.h>
#include <unistd.h>
#include "myColor.h"
#include "custom-utils.h"
#include "curse-files.h"

#include <limits.h>
/* SECTION OF CODE AI-GENERATED BY GOOGLE GEMINI:*/

/* * Helper function to get the standard RGB (0-255) value
 * for a specific bash 256-color code (0-255).
 */
void get_bash_color_rgb(int code, int *r, int *g, int *b) {
    // 1. Standard System Colors (0-15)
    // These specific hex values are the standard Xterm defaults.
    if (code < 16) {
        // 0-7: Standard
        if (code == 0) { *r = 0;   *g = 0;   *b = 0;   }      // Black
        else if (code == 1) { *r = 128; *g = 0;   *b = 0;   } // Maroon
        else if (code == 2) { *r = 0;   *g = 128; *b = 0;   } // Green
        else if (code == 3) { *r = 128; *g = 128; *b = 0;   } // Olive
        else if (code == 4) { *r = 0;   *g = 0;   *b = 128; } // Navy
        else if (code == 5) { *r = 128; *g = 0;   *b = 128; } // Purple
        else if (code == 6) { *r = 0;   *g = 128; *b = 128; } // Teal
        else if (code == 7) { *r = 192; *g = 192; *b = 192; } // Silver
        // 8-15: High Intensity (Bright)
        else if (code == 8) { *r = 128; *g = 128; *b = 128; } // Grey
        else if (code == 9) { *r = 255; *g = 0;   *b = 0;   } // Red
        else if (code == 10){ *r = 0;   *g = 255; *b = 0;   } // Green
        else if (code == 11){ *r = 255; *g = 255; *b = 0;   } // Yellow
        else if (code == 12){ *r = 0;   *g = 0;   *b = 255; } // Blue
        else if (code == 13){ *r = 255; *g = 0;   *b = 255; } // Magenta
        else if (code == 14){ *r = 0;   *g = 255; *b = 255; } // Cyan
        else if (code == 15){ *r = 255; *g = 255; *b = 255; } // White
        return;
    }

    // 2. 6x6x6 Color Cube (16-231)
    // Formula: 16 + (36 * r) + (6 * g) + b
    if (code < 232) {
        int cube_code = code - 16;
        int r_idx = cube_code / 36;
        int g_idx = (cube_code % 36) / 6;
        int b_idx = cube_code % 6;

        // Mapping 0-5 index to specific byte values used by Xterm
        // 0 -> 0, non-zero -> (index * 40 + 55)
        // Sequence: 0, 95, 135, 175, 215, 255
        *r = (r_idx == 0) ? 0 : (r_idx * 40 + 55);
        *g = (g_idx == 0) ? 0 : (g_idx * 40 + 55);
        *b = (b_idx == 0) ? 0 : (b_idx * 40 + 55);
        return;
    }

    // 3. Grayscale Ramp (232-255)
    // Formula: 232 is 0x08 (8), each step adds 10 (0x0A).
    // Ends at 238 (0xEE).
    if (code < 256) {
        int gray_idx = code - 232;
        int val = 8 + (gray_idx * 10);
        *r = val;
        *g = val;
        *b = val;
        return;
    }
}

int bash_code_closest_match(Color color) {
    // 1. Normalize input (0-1000) to standard RGB (0-255)
    // We use integer math: (val * 255) / 1000
    int target_r = (color.rgb.r * 255) / 1000;
    int target_g = (color.rgb.g * 255) / 1000;
    int target_b = (color.rgb.b * 255) / 1000;

    int best_code = 0;
    long min_distance_sq = LONG_MAX;

    // 2. Iterate over all 256 colors to find the closest match
    for (int code = 0; code < 256; code++) {
        int r, g, b;
        get_bash_color_rgb(code, &r, &g, &b);

        // Calculate squared Euclidean distance
        long dr = r - target_r;
        long dg = g - target_g;
        long db = b - target_b;
        long distance_sq = (dr * dr) + (dg * dg) + (db * db);

        if (distance_sq < min_distance_sq) {
            min_distance_sq = distance_sq;
            best_code = code;

            // Optimization: If exact match, break early
            if (min_distance_sq == 0) return best_code;
        }
    }

    return best_code;
}
/* END OF SECTION OF AI-GENERATED CODE */

/*
 * TABLE-OF-EFFECTS:
 * 0 - NORMAL/RESET
 * 1 - BOLD
 * 2 - FAINT
 * 3 - ITALIC
 * 4 - UNDERLINE
 * 5 - BLINK
 * 6 - MY DEFINITION - when in color, use terminal defaults
 * 7 - REVERSE
 */
void translate(attr_t mask, Context context, int result[3], bool with_color, bool withBgColor){
	result[0] = 0;
	if( mask & A_BOLD ){
		result[0] = 1;
	}
	if( mask & A_INVIS ){
		result[0] = 2;
	}
	if( mask & A_ITALIC ){
		result[0] = 3;
	}
	if( mask & A_UNDERLINE ){
		result[0] = 4;
	}
	if( mask & A_BLINK ){
		result[0] = 5;
	}
	if( mask & A_REVERSE ){
		result[0] = 7;
	}

	if( with_color ){
		Pair toCodify;
		short attrPairNum = PAIR_NUMBER(mask);
		Pair* pairs = context.color_pairs.colPointer;

		if( !withBgColor && attrPairNum == 0 && result[0] == 0 ){
			result[0] = 6;
			return;
		}

		for( int i = 0; i < context.color_pairs.maxDim; i++ ){
			if( pairs[i].pairNum == attrPairNum){
				toCodify = pairs[i];
				break;
			}
		}
		result[1] = bash_code_closest_match(toCodify.fg);
		result[2] = bash_code_closest_match(toCodify.bg);
	}
}

void codify_visual_string(char* stringToCode, int maxlen, int code[3], bool with_color){
	if(with_color && code[0] != 6){
		snprintf(stringToCode, maxlen, 
			"\\e[%d;38;5;%d;48;5;%dm", 
			code[0], code[1], code[2]);
	}
	else{
		snprintf(stringToCode, maxlen, 
			"\\e[%d;m", 
			code[0] == 6 ? 0: code[0]);
	}
	return;
}


int main(int argc, char** argv){
	chtype ch;
	Context context;
	int newCodes[3];
	char newCodeString[64];
	bool with_color = true;
	int fd;
	int newFile;
	int filePos;
	int opt;
	bool toPrint = false;
	bool withBgColor = true;

	while ((opt = getopt(argc, argv, "hcb")) != -1) {
			switch (opt) {
				case 'c':
					with_color = false;
					break;
				case 'h':
					printf("This program will translate a .curses file formatted correctly\n\
and write it to a file called BashCodedFile.\n-c for no color\n-h for this help\n\
-b to preserve black background color of uncolored cells\n");
					exit(0);
				case 'b':
					withBgColor = false;
					break;
			}
	}

	if( argc < 2 ){
		puts("Expected name of file\n");
		return -1;
	}

	fd = open(argv[optind], O_RDONLY);
	if( fd < 0 ){
		puts("Expected name of existing file\n");
		return -1;
	}
	newFile = open("BashCodedFile", O_TRUNC | O_WRONLY | O_CREAT, 0644);
	if( newFile < 0 ){
		puts("Error creating new file\n");
		return -1;
	}

	initialize_collection(&context.color_pairs, 126, sizeof(Pair));
	initialize_collection(&context.custom_colors, 255, sizeof(Color));
	
	//assuming it is .curse file formatted correctly
	filePos = initialize_colors_from_file(fd, 0, &context);

	if( filePos < 1 ){
		puts("Error reading colors from file");
		return -2;
	}

	filePos = initialize_pairs_from_file(fd, filePos, &context);
	if( filePos < 1 ){
		puts("Error reading pairs from file");
		return -2;
	}

	int nread;
	attr_t cur, prev = -1;

	lseek(fd, filePos, SEEK_SET);

	while( (nread = read(fd, &ch, sizeof(chtype))) > 0){
		cur = ch & 0xffffff00;
		if( cur != prev ){
			translate(cur, context, newCodes, with_color, withBgColor);

			codify_visual_string(newCodeString, sizeof(newCodeString), newCodes, with_color);

			write(newFile, newCodeString, strlen(newCodeString));

			prev = cur;
		}
		ch = ch & A_CHARTEXT;

		if( ch == '\n' ){ write(newFile, "\\n", 2); }
		else if( ch == '\\' ) write(newFile, "\\\\", 2);
		else write(newFile, &ch, sizeof(char));
	}

	write(newFile, "\\e[0m", strlen("\\e[0m"));

	free(context.color_pairs.colPointer);
	free(context.custom_colors.colPointer);
}
